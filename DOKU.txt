Doku: Anfangsziel war rudimentäres Spiel zu bauen um Aspekte zu testen und zu lernen. Das führte zu mehreren Iterationen besonders an der SteuerungBeim Auseinandersetzen mit MLAgents ist mir aufgefallen, dass die Art auf die Rewards in Reinforced Learning gegeben werden eine hohe Chance hat nicht kompatibel mit der Genre des Spiels zu sein, da
      die Rewards durch seperate Handlungen von Einheiten gegeben werden soll, zudem das Agenten Skript nicht natürlichweise direkten Zugriff hat. Sofern ist der Zyklus des Reinforced learning hierdurch bei dem "Reward" Schritt verzögert, falls Rewards außerhalb dieses Skripts gegeben werden sollen. Deshalb lag für mich hierauf der Fokus während der Einarbeitung und hierfür wurden auch die meisten Iterationen gemacht, um das auf irgendeine weise zu ermöglichen.
      Wichtig war außerdem die Benutzung und Einstellung der Konfigurationsdatei des Netzwerks. Das Training kann um einige größen effizienter sein, wenn man es richtig an seine Situation anpasst. Nicht zu vergessen Curriculum Training existiert.
      Steuerung ist sehr wichtig. Programmatisch ist die Steuerung für die AI nichts speziell anspruchsvolles. Für das Selbstspielen durch die Implementierung der Heuristic Funktion (welche blablabla...) merkt man aber direkt, dass mehrere bestimmte Befehle nicht direkt gegeben werden können. Man kann also im normalfall nicht direkt diagonal gehen, wenn man eine Steuerung implementiert hat
      welche die normale WASD Steuerung abbilden soll. Generell war ein wichtiger Aspekt, welcher öfter geändert wurde geprägt durch die Frage "Wie rudimentär kann oder muss ich dieses Feature machen, um das Verhalten durch den Agenten und seine Umgebung zu bekommen, die ich will".

22.06.2023 Die Wahl viel auf ein sehr bekanntes Spiel Konzept für das Thema, eine Tower Defense. Nicht ganz die allseits bekannte Art, sondern wie in Wintermaul Wars in WC III. Die Idee war zu Anfangs zwei Spieler zu haben, welche jeweils eine limitierte Fläche zum bauen haben und diese benutzen um Türme zu bauen, aber gleichzeitig auch Ressourcen verbrauchen um Einheiten gegen den Gegner los zuschicken. Das Ziel war die Einheiten bis in die gegnerische Basis zu senden, wo sie Lebenspunkte abziehen sollen, bis dieser 0 Lebenspunkte hat. Das Layout und der Mix aus verschiedenen Turm Typen ist wichtig für die Defensive. Sowohl auch eine Balance zwischen senden versch. Einheiten
und bauen der Türme. Aber zwei KI zu haben welche auf "verschiedenene" Konzepte (Angriff und Defensive) gleichzeitig trainiert werden, hat sich auf weiteren Blick als zu komplex für diese Arbeit herausgestellt. Die Wahl viel auf ein Asymmetry, bei der ein Spieler die Defensive hat und der andere die Offensive (Monster schicken). So ist hier noch ausreichend Komplexität zu finden um die KI zu trainieren gegeneinander zu spielen und sich zu verbessern. Die Höhe der Komplexität die man hier erreichen kann ist beliebig und wird je nach Eigenresultat angepasst.    
Wichtig gegen Anfang war das richtige Layout des Tower Defense spiels zu finden -> hier anlehnung and Wintermaul Wars und ähnliche "Fun Games" im Spiel Warcraft III. Ziel war es Ein  anfangs simples Spielfeld zu haben, das nach Bedarf erweitert werden kann, so muss also der Code gut und schnell anpassbar sein. Hier war ein sehr gut anpassbares Grid System erforderlich, um eine eventuell große und Komplexe Anzahl an Informationen zu speichern.
      Dies wird nicht nur bei dem Platzieren der Türme wichtig, sondern auch für das Pathfinding der Monster und weiter in die Zukunft geschaut, für das Logging und visualisieren und Daten.

23.06.2023 mehr Modularität innerhalb der Grid Cells durch einfügen komplexer Objekte als Referenz Punkt für eine Zelle. Entscheidung für Einfaches Targetting, nicht Physiks based bei Projektilen (for now)

28.06.2023  Umschwung auf Unity TD Beispiel anstelle von Eigenentwickelten Prototypen. Vorteile : Großteil der gewollten Funktionen sind vorhanden - Modularität vorhanden - hohe Qualität des Beispiels in Struktur des Codes; Nachteil: Relativ anspruchsvoll zum Einlesen und spezielles umbauen von Strukturen nach späterem Bedarf -> Fazit: Zeitvergleich von Einlesen zu Eigenentwicklung ungewiss, aber Funktionalitäten vorhanden und überschaubar und hochqualitativ und deswegen wird diese Methode verwendet.

30.06.2023 Lange Debug Zeit da ich mich durch die Call Hierarchy durchhangeln muss um Bugs/Fehler zu finden in meinen Skripts, da ich funktionen aus ihrem Kontext reiße und im Agenten Skript aufrufe. Nicht direkte Dependencies wirken gegen mich, manche Funktionen sind zu tief in der Hierarchy, also muss man für die Funktionalität welche aufrufen die höher sind -> den Effekt der Funktionen und die Dependencies zu finden dauert Zeit.




04.07.2023 Alle Resets der Szene durch den Action delegate machen (homeBaseDestroyed in LevelManager) der von allen Notwendigen Funktionen der Funktionalitäten subscribed wird. Anfügen von kleinen Funktionen wenn nötig.
05.07.2023 Je nach Gewinn oder Verlust entsprechende delegates aufrufen, welche die entsprechenden Rewardfunktionen im Agentskript aufrufen, welche den resetAll delegate (vorher homeBaseDestroyed delegate) aufrufen.



10.07.2023 Switch von propriäterem Timer auf C# Timer class, propriäterer Timer war zu unübersichtlich und teilweise fraglich benutzt
11.07.2023 C# Timer Benutzung nicht möglich, da threaded und get_gameObject methoden nicht aufrufbar in Threads (was benutzt wurde -> wäre zu unnötig komplex gewesen das zu versuchen zu ändern)
	   jetzt einfach TimedWave weggelassen und Wave nur benutzt
	   Angefangen mit Observationen von TowerBuild coordinates, Tower type and Currency. Eventuelles Problem mit Aufrufreihenfolge, da die variables in BuildTower assigned werden, aber in CollectObservations abgerufen (needs to be tested)


13.07.2023 Setup der Szene für Training optimiert -> kleineres Grid und ausstellen der Animationen und Sounds. anfänglich lange Testläufe ~30min - ~1h30min